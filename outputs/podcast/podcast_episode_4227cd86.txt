[00:00:00] [진행자]: 안녕하세요! 기술의 최전선을 탐험하는 테크 인사이트입니다. 오늘은 LLM, 즉 거대 언어 모델을 활용한 AI 에이전트 개발의 새로운 지평을 열고 있는 랭그래프LangGraph에 대해 심도 깊은 이야기를 나눠볼 텐데요. 특히 꿈 많은 사람의 이야기 블로그를 통해 이 주제를 깊이 있게 다뤄주신 이수진 님을 모셨습니다. 이수진 님, 반갑습니다!
[00:00:26] [게스트]: 네, 안녕하세요! 꿈 많은 사람의 이야기 블로그를 운영하는 이수진입니다. 오늘 랭그래프에 대한 흥미로운 토론에 참여하게 되어 기쁩니다.
[00:00:36] [진행자]: 좋습니다.이수진 님의 블로그 글을 보니, LLM 애플리케이션이 단순한 모델 호출을 넘어 복잡한 로직을 필요로 할 때 랭그래프가 핵심적인 역할을 한다고 하셨습니다.그런데 말이죠, 이수진 님, 저희가 기존에 랭체인LangChain이라는 강력한 도구를 이미 가지고 있지 않습니까?
[00:00:59] [진행자]: 굳이 이렇게 복잡한 그래프 형태의 구조까지 도입해서 LLM 에이전트를 만들어야 할까요?개발 과정을 너무 복잡하게 만드는 건 아닌가요?
[00:01:09] [게스트]: 웃음 진행자님, 아주 날카로운 질문이시네요.랭체인이 훌륭한 도구인 것은 맞지만, 랭체인이 중점을 둔 것은 LLM과 외부 도구들을 연쇄적으로chaining 연결하는 방식입니다.마치 기차처럼 한 방향으로 쭉 이어지는 구조죠.하지만 현실의 LLM 에이전트는 그렇게 단순하게 작동하지 않습니다.
[00:01:33] [게스트]: 예를 들어, 사용자로부터 추가 질문을 받아야 할 때, 특정 조건이 만족될 때까지 작업을 반복해야 할 때, 혹은 여러 도구 중 어떤 것을 사용할지 동적으로 판단해야 할 때가 많습니다.
[00:01:47] [진행자]: 음... 말씀하신 반복이나 동적 판단 같은 기능이요? 그런 건 기존 프로그래밍 언어의 ifelse 문이나 반복문으로도 충분히 구현할 수 있지 않나요? 굳이 그래프라는 새로운 패러다임을 가져와서 학습 곡선을 높일 필요가 있을까요?
[00:02:04] [게스트]: 물론 단순한 조건문으로 처리할 수 있는 부분도 있습니다.하지만 에이전트의 행동이 복잡해질수록, 이 ifelse 문들이 얽히고설켜서 코드의 가독성과 유지보수성이 급격히 떨어지게 됩니다.랭그래프는 이런 복잡한 흐름을 그래프라는 시각적이고 직관적인 형태로 설계하고 제어할 수 있게 해줍니다.
[00:02:26] [게스트]: 핵심은 상태State를 유지하면서 순환 구조를 포함한 다단계 작업을 명확하게 관리하는 것입니다.
[00:02:35] [진행자]: 상태 유지와 순환 구조요? 조금 더 구체적으로 설명해주실 수 있을까요? 일반적인 개발자들에게는 아직 생소하게 들릴 수 있을 것 같습니다.
[00:02:46] [게스트]: 네, 랭그래프의 핵심 구성 요소 세 가지를 이해하시면 쉽습니다.첫째, 상태State는 에이전트의 메모리라고 생각하시면 됩니다.대화 기록, 중간 결과, 사용자 정보 등 에이전트가 기억해야 할 모든 정보가 이 상태에 담겨서 다음 단계로 전달됩니다.둘째, 노드Nodes는 그래프의 작업 단위입니다.
[00:03:10] [게스트]: LLM을 호출하거나 특정 도구를 사용하는 등의 구체적인 작업을 수행하는 함수들이죠.셋째, 엣지Edges는 이 노드들을 연결하는 경로입니다.정보와 제어 흐름이 어떤 순서로 이어질지 결정하는 역할을 합니다.특히 랭그래프는 이 엣지에 조건부 로직을 부여할 수 있어서, 에이전트가 상황에 따라 유연하게 다음 행동을 결정할 수 있게 됩니다.
[00:03:35] [게스트]: 이것이 단순한 체인으로는 구현하기 어려운 부분이죠.
[00:03:40] [진행자]: 아, 메모리와 작업 단위, 그리고 경로로 추상화해서 복잡한 흐름을 관리한다는 말씀이시군요.이해가 됩니다.그런데 블로그 글의 예제 코드를 보면, vLLM 서버에 Qwen3 모델을 연동해서 챗봇을 만드셨더라고요.솔직히 일반 개발자들이 로컬 환경에서 vLLM 서버를 구축하고 특정 모델을 사용하는 것은 꽤 높은 기술적 장벽처럼 느껴지는데요?
[00:04:09] [진행자]: 랭그래프의 핵심 개념을 설명하는 데 굳이 이렇게 복잡한 환경을 선택하신 이유가 있을까요?오히려 접근성을 떨어뜨리는 것은 아닌가 하는 우려도 드는데요.
[00:04:21] [게스트]: 단호하게 좋은 지적이십니다.물론 예제 환경 자체는 다소 복잡하게 느껴질 수 있습니다.하지만 제가 이 예제를 선택한 이유는, 랭그래프가 실제 프로덕션 환경에서 마주할 수 있는 다양한 기술 스택과 얼마나 유연하게 연동될 수 있는지를 보여드리고 싶었기 때문입니다.
[00:04:41] [게스트]: ChatOpenAI 인터페이스를 사용하면서도 실제 LLM은 로컬 서버의 Qwen3 모델을 활용하는 방식은, 랭그래프가 특정 LLM이나 배포 방식에 종속되지 않고 추상적인 흐름 제어에 집중한다는 것을 강조합니다.
[00:04:58] [게스트]: 핵심은 어떤 LLM을 쓰든, 어떤 환경에 배포하든, 랭그래프를 통해 복잡한 LLM 에이전트의 로직과 흐름을 명확하게 제어할 수 있다는 점입니다.
[00:05:10] [진행자]: 그렇군요. 예제 환경의 복잡성보다는 랭그래프가 제공하는 제어의 유연성과 확장성에 초점을 맞추셨다는 말씀이시네요. 단순히 ifelse 문을 나열하는 것과는 차원이 다른, 마치 AI 에이전트의 뇌 속 신경망을 설계하는 듯한 느낌을 받습니다.
[00:05:30] [게스트]: 맞습니다!에이전트가 단순히 질문에 답하는 것을 넘어, 상황을 인지하고, 계획을 세우고, 필요한 도구를 사용하며, 심지어는 자기 수정까지 하는 등 복잡한 인지 과정을 수행하려면 이런 설계도가 필수적입니다.랭그래프는 바로 그런 복잡한 에이전트의 뼈대를 제공하는 셈이죠.
[00:05:52] [게스트]: 다음 포스팅에서는 더 나아가 조건부 엣지를 활용해서 여러 도구를 사용하고, 동적으로 판단하는 더 발전된 에이전트 예제를 보여드릴 예정입니다.
[00:06:04] [진행자]: 와, 정말 기대가 됩니다. 단순히 기술을 소개하는 것을 넘어, 왜 이런 기술이 필요한지, 그리고 어떤 문제를 해결하는지에 대한 명확한 비전을 제시해주셔서 감사합니다. 오늘 이수진 님 덕분에 랭그래프가 단순한 유행을 넘어, LLM 에이전트 개발의 필수적인 도구가 될 수 있겠다는 균형 잡힌 시각을 얻게 된 것 같습니다. 오늘 말씀 감사합니다, 이수진 님!
[00:06:30] [게스트]: 초대해주셔서 감사합니다.
[00:06:33] [진행자]: 네, 지금까지 테크 인사이트였습니다. 다음 시간에도 흥미로운 주제로 찾아뵙겠습니다!